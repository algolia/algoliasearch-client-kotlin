/**
 * Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be
 * lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
 */
package com.algolia.client.model.recommend

import com.algolia.client.exception.AlgoliaClientException
import com.algolia.client.extensions.internal.*
import kotlin.jvm.JvmInline
import kotlinx.serialization.*
import kotlinx.serialization.builtins.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*
import kotlinx.serialization.json.*

/**
 * Words that should be considered optional when found in the query. By default, records must match
 * all words in the search query to be included in the search results. Adding optional words can
 * help to increase the number of search results by running an additional search query that doesn't
 * include the optional words. For example, if the search query is \"action video\" and \"video\" is
 * an optional word, the search engine runs two queries. One for \"action video\" and one for
 * \"action\". Records that match all words are ranked higher. For a search query with 4 or more
 * words **and** all its words are optional, the number of matched words required for a record to be
 * included in the search results increases for every 1,000 records: - If `optionalWords` has less
 * than 10 words, the required number of matched words increases by 1: results 1 to 1,000 require 1
 * matched word, results 1,001 to 2000 need 2 matched words. - If `optionalWords` has 10 or more
 * words, the number of required matched words increases by the number of optional words divided by
 * 5 (rounded down). For example, with 18 optional words: results 1 to 1,000 require 1 matched word,
 * results 1,001 to 2000 need 4 matched words. For more information, see
 * [Optional words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/empty-or-insufficient-results/#creating-a-list-of-optional-words).
 *
 * Implementations:
 * - [List<String>] - *[OptionalWords.of]*
 * - [String] - *[OptionalWords.of]*
 */
@Serializable(OptionalWordsSerializer::class)
public sealed interface OptionalWords {
  @Serializable @JvmInline public value class StringValue(public val value: String) : OptionalWords

  @Serializable
  @JvmInline
  public value class ListOfStringValue(public val value: List<String>) : OptionalWords

  public companion object {

    public fun of(value: String): OptionalWords = StringValue(value)

    public fun of(value: List<String>): OptionalWords = ListOfStringValue(value)
  }
}

internal class OptionalWordsSerializer :
  JsonContentPolymorphicSerializer<OptionalWords>(OptionalWords::class) {
  override fun selectDeserializer(element: JsonElement): DeserializationStrategy<OptionalWords> {
    return when {
      element.isString -> OptionalWords.StringValue.serializer()
      element is JsonArray -> OptionalWords.ListOfStringValue.serializer()
      else -> throw AlgoliaClientException("Failed to deserialize json element: $element")
    }
  }
}
