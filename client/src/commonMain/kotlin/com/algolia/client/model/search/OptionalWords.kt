/** Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT. */
package com.algolia.client.model.search

import com.algolia.client.exception.AlgoliaClientException
import com.algolia.client.extensions.internal.*
import kotlinx.serialization.*
import kotlinx.serialization.builtins.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*
import kotlinx.serialization.json.*
import kotlin.jvm.JvmInline

/**
 * Words that should be considered optional when found in the query.  By default, records must match all words in the search query to be included in the search results. Adding optional words can help to increase the number of search results by running an additional search query that doesn't include the optional words. For example, if the search query is \"action video\" and \"video\" is an optional word, the search engine runs two queries. One for \"action video\" and one for \"action\". Records that match all words are ranked higher.  For a search query with 4 or more words **and** all its words are optional, the number of matched words required for a record to be included in the search results increases for every 1,000 records:  - If `optionalWords` has less than 10 words, the required number of matched words increases by 1:   results 1 to 1,000 require 1 matched word, results 1,001 to 2000 need 2 matched words. - If `optionalWords` has 10 or more words, the number of required matched words increases by the number of optional words divided by 5 (rounded down).   For example, with 18 optional words: results 1 to 1,000 require 1 matched word, results 1,001 to 2000 need 4 matched words.  For more information, see [Optional words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/empty-or-insufficient-results/#creating-a-list-of-optional-words).
 *
 * Implementations:
 * - [List<String>] - *[OptionalWords.of]*
 * - [String] - *[OptionalWords.of]*
 */
@Serializable(OptionalWordsSerializer::class)
public sealed interface OptionalWords {
  @Serializable
  @JvmInline
  public value class StringValue(public val value: String) : OptionalWords

  @Serializable
  @JvmInline
  public value class ListOfStringValue(public val value: List<String>) : OptionalWords

  public companion object {

    public fun of(value: String): OptionalWords = StringValue(value)

    public fun of(value: List<String>): OptionalWords = ListOfStringValue(value)
  }
}

internal class OptionalWordsSerializer : JsonContentPolymorphicSerializer<OptionalWords>(OptionalWords::class) {
  override fun selectDeserializer(element: JsonElement): DeserializationStrategy<OptionalWords> = when {
    element.isString -> OptionalWords.StringValue.serializer()
    element is JsonArray -> OptionalWords.ListOfStringValue.serializer()
    else -> throw AlgoliaClientException("Failed to deserialize json element: $element")
  }
}
